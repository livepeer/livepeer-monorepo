"""
Livepeer protocol global parameters
"""
type Protocol @entity {
  "ID is set to 0"
  id: ID!
  "Per round inflation rate"
  inflation: BigInt!
  "Change in inflation rate per round until the target bonding rate is achieved"
  inflationChange: BigInt!
  "Max number of rounds that a caller can claim earnings for at once"
  maxEarningsClaimsRounds: BigInt!
    @deprecated(reason: "This constraint of was removed as of LIP-52")
  "Total active transcoders"
  numActiveTranscoders: BigInt!
  "True if the protocol is paused"
  paused: Boolean!
  "Target bonding rate (participation) that determines whether inflation should increase or decrease"
  targetBondingRate: BigInt!
  "Time in blocks needed to wait to unstake"
  unbondingPeriod: BigInt!
  "Time in blocks delegators have to review transcoder information without changes"
  lockPeriod: BigInt!
  "Lock period of a round as a % of round length"
  roundLockAmount: BigInt!
  "The total amount of active LPT staked"
  totalActiveStake: BigDecimal!
  "Total broadcaster fees transcoders have accumulated in ETH"
  totalVolumeETH: BigDecimal!
  "Total broadcaster fees transcoders have accumulated in USD"
  totalVolumeUSD: BigDecimal!
  "Ratio of total active stake to total supply"
  participationRate: BigDecimal!
  "Current round the protocol is in"
  currentRound: Round
  "Round that was last initialized"
  lastInitializedRound: Round
  "Round when round length was last updated"
  lastRoundLengthUpdateRound: Round
  "Round length in blocks"
  roundLength: BigInt!
  "Block when round length was last updated"
  lastRoundLengthUpdateStartBlock: BigInt!
  "Total rounds"
  roundCount: BigInt!
  "Total winning tickets"
  totalWinningTickets: BigInt!
  "Livepeer Token supply"
  totalSupply: BigDecimal!
}

"""
Perform transcoding work for the network. The transcoders with the most delegated stake are elected as active transcoders that process transcode jobs for the network.
"""
type Transcoder @entity {
  "Transcoder's ETH address"
  id: ID!
  "Round in which the transcoder became active - 0 if inactive"
  activationRound: BigInt!
  "Round in which the transcoder will become inactive"
  deactivationRound: BigInt!
  "Round for which the stake was last updated while the transcoder is active"
  lastActiveStakeUpdateRound: BigInt!
  "Whether or not the transcoder is active"
  active: Boolean!
  "Status of the transcoder"
  status: TranscoderStatus!
  "Last round that the transcoder called reward"
  lastRewardRound: Round!
  "% of block reward cut paid to transcoder by a delegator"
  rewardCut: BigInt!
  "% of fees paid to delegators by transcoder"
  feeShare: BigInt!
  "Price per segment for a stream"
  pricePerSegment: BigInt
    @deprecated(reason: "Price negotiation moved offchain")
  "Pending price per segment for next round if the transcoder is active"
  pendingPricePerSegment: BigInt
    @deprecated(reason: "Price negotiation moved offchain")
  "Pending block reward cut for next round if the transcoder is active"
  pendingRewardCut: BigInt @deprecated(reason: "Field no longer used")
  "Pending fee share for next round if the transcoder is active"
  pendingFeeShare: BigInt @deprecated(reason: "Field no longer used")
  "Total tokens delegated toward a transcoder (including their own)"
  totalStake: BigDecimal!
  "Total fees generated by the transcoder in ETH (before distribution to delegators)"
  totalVolumeETH: BigDecimal!
  "Total fees generated by the transcoder in USD (before distribution to delegators)"
  totalVolumeUSD: BigDecimal!
  "Pools associated with the transcoder"
  pools: [Pool!] @derivedFrom(field: "delegate")
  "Delegators bonded to the transcoder"
  delegators: [Delegator!] @derivedFrom(field: "delegate")
  "Delegator that registered this transcoder"
  delegator: Delegator
  "Service URI endpoint that can be used to send off-chain requests"
  serviceURI: String
}

enum TranscoderStatus @entity {
  NotRegistered
  Registered
}

"""
Represents a transcoder's rewards and fees to be distributed to delegators
"""
type Pool @entity {
  "Unique identifer for the pool (formed using the transcoder's address and round number)"
  id: ID!
  "Round associated with the pool"
  round: Round!
  "Transcoder associated with the pool"
  delegate: Transcoder!
  "Fees collected in the pool"
  fees: BigDecimal
  "Total reward tokens collected in the pool"
  rewardTokens: BigDecimal
  "Transcoder's total stake during the earnings pool's round"
  totalStake: BigDecimal!
  "Transcoder's reward cut during the earnings pool's round"
  rewardCut: BigInt!
  "Transcoder's fee share during the earnings pool's round"
  feeShare: BigInt!
}

"""
The Livepeer protocol is round based and each round is represented by some number of Ethereum blocks.
"""
type Round @entity {
  "Round number"
  id: ID!
  "Whether the round was initialized"
  initialized: Boolean!
  "Number of blocks this round lasts for"
  length: BigInt!
  "Start block for the round"
  startBlock: BigInt!
  "End block for the round"
  endBlock: BigInt!
  "Pools associated with the round"
  pools: [Pool!] @derivedFrom(field: "round")
  "Mintable tokens for the round"
  mintableTokens: BigDecimal!
  "Fees generated this round in ETH"
  volumeETH: BigDecimal!
  "Fees generated this round in USD"
  volumeUSD: BigDecimal!
  "Total active stake during the round"
  totalActiveStake: BigDecimal!
  "Total Livepeer token supply during the round"
  totalSupply: BigDecimal!
  "Participation rate during the round (totalActiveStake/totalSupply)"
  participationRate: BigDecimal!
  "Total stake moved from one delegate to another during the round"
  movedStake: BigDecimal!
  "Total amount of new stake introduced during the round"
  newStake: BigDecimal!
}

"""
Bonded accounts who have delegated their stake towards a transcoder candidate
"""
type Delegator @entity {
  "ETH address of a delegator"
  id: ID!
  "ETH address of the delegate (the one whom the delegator has bonded to)"
  delegate: Transcoder
  "Round the delegator becomes bonded and delegated to its delegate"
  startRound: BigInt!
  "Last round that the delegator claimed reward and fee pool shares"
  lastClaimRound: Round!
  "Amount of Livepeer Token a delegator currently has bonded"
  bondedAmount: BigDecimal!
  "Amount of Livepeer Token a delegator has bonded over its lifetime separate from rewards"
  principal: BigDecimal!
  "Amount of Livepeer Token a delegator has unbonded over its lifetime"
  unbonded: BigDecimal!
  "Amount of fees a delegator has collected"
  fees: BigDecimal!
  "Amount of fees withdrawn"
  withdrawnFees: BigDecimal!
  "Amount of Livepeer Token the delegator has delegated"
  delegatedAmount: BigDecimal!
  "Unbonding locks associated with the delegator"
  unbondingLocks: [UnbondingLock!] @derivedFrom(field: "delegator")
}

"""
Broadcasters pay transcoders to do the work of transcoding in exchange for fees
"""
type Broadcaster @entity {
  "ETH address of a broadcaster"
  id: ID!
  "Amount of funds deposited"
  deposit: BigDecimal!
  "Amount of funds in reserve"
  reserve: BigDecimal!
}

"""
Get an unbonding lock for a delegator
"""
type UnbondingLock @entity {
  "Unique unlock identifer"
  id: ID!
  "unbonding lock id"
  unbondingLockId: Int!
  "Delegator address this lock belongs to"
  delegator: Delegator!
  "Address of delegate unbonding from"
  delegate: Transcoder!
  "Amount being unbonded"
  amount: BigDecimal!
  "Round number when the unbonding amount will be available for withdrawal"
  withdrawRound: BigInt!
}

"""
Stake weighted poll
"""
type Poll @entity {
  "Poll address"
  id: ID!
  "IPFS multihash for the proposal"
  proposal: String!
  "Block at which the poll ends and votes can no longer be submitted"
  endBlock: BigInt!
  "Minimum amount of participation (total stake including inactive stake) required for a poll to pass"
  quorum: BigInt!
  "Minimum amount of yes votes required for a poll to pass"
  quota: BigInt!
  "Poll tally"
  tally: PollTally
  "Votes belonging to a poll"
  votes: [Vote!]
}

"""
Stake weighted tally associated with a poll
"""
type PollTally @entity {
  "Poll address"
  id: ID!
  "Stake voted yes"
  yes: BigDecimal
  "Stake voted no"
  no: BigDecimal
}

"""
Vote data
"""
type Vote @entity {
  "Voter address + poll address"
  id: ID!
  "Vote caster"
  voter: String!
  "Stake weighted vote"
  voteStake: BigDecimal
  "This will be non-zero if voter is an transcoder and any of the its delegators voted"
  nonVoteStake: BigDecimal
  "Vote choice"
  choiceID: PollChoice
  "Poll associated with this vote"
  poll: Poll
  "True if the voter was a registered transcoder during the poll period"
  registeredTranscoder: Boolean
}

enum PollChoice @entity {
  Yes
  No
}

"""
Protocol data accumulated and condensed into day stats
"""
type Day @entity {
  "Timestamp rounded to current day by dividing by 86400"
  id: ID!
  "The date beginning at 12:00am UTC"
  date: Int!
  "Fees generated this day in ETH"
  volumeETH: BigDecimal!
  "Fees generated this day in USD"
  volumeUSD: BigDecimal!
  "Total active stake during the day"
  totalActiveStake: BigDecimal!
  "Total Livepeer token supply during the day"
  totalSupply: BigDecimal!
  "Participation rate during the day (totalActiveStake/totalSupply)"
  participationRate: BigDecimal!
}

"""
Transcoder data accumulated and condensed into day stats
"""
type TranscoderDay @entity {
  "Combination of the transcoder address and the timestamp rounded to current day by dividing by 86400"
  id: ID!
  "The date beginning at 12:00am UTC"
  date: Int!
  "Fees generated this day in ETH"
  volumeETH: BigDecimal!
  "Fees generated this day in USD"
  volumeUSD: BigDecimal!
  "Transcoder associated with the day"
  transcoder: Transcoder!
}

###############################################################################
#
# Event types && transactions for historical records
#
###############################################################################
interface Event {
  id: ID!
  timestamp: Int!
  transaction: Transaction!
  round: Round!
}

type Transaction @entity {
  id: ID!
  blockNumber: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  timestamp: Int!
  from: String!
  to: String!
  events: [Event!] @derivedFrom(field: "transaction")
}

type BondEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  bondedAmount: BigDecimal!
  additionalAmount: BigDecimal!
  newDelegate: Transcoder!
  oldDelegate: Transcoder!
  delegator: Delegator!
}

type UnbondEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  amount: BigDecimal!
  withdrawRound: BigInt!
  unbondingLockId: Int
  delegate: Transcoder!
  delegator: Delegator!
}

type RewardEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  rewardTokens: BigDecimal!
  delegate: Transcoder!
}

type TranscoderActivatedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegate: Transcoder!
  activationRound: BigInt!
}

type TranscoderDeactivatedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegate: Transcoder!
  deactivationRound: BigInt!
}

type EarningsClaimedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegator: Delegator!
  delegate: Transcoder!
  startRound: Round!
  endRound: Round!
  rewardTokens: BigDecimal!
  fees: BigDecimal!
}

type RebondEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegator: Delegator!
  delegate: Transcoder!
  amount: BigDecimal!
  unbondingLockId: Int!
}

type TranscoderUpdateEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegate: Transcoder!
  rewardCut: BigInt!
  feeShare: BigInt!
}

type TranscoderSlashedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegate: Transcoder!
  finder: Bytes!
  penalty: BigDecimal!
  finderReward: BigInt!
}

type TranscoderResignedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegate: Transcoder!
}

type TranscoderEvictedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegate: Transcoder!
}

type WithdrawStakeEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegator: Delegator!
  unbondingLockId: Int
  amount: BigDecimal!
}

type WithdrawFeesEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  delegator: Delegator!
  amount: BigDecimal!
}

type NewRoundEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  blockHash: String!
}

type WinningTicketRedeemedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  sender: Broadcaster!
  recipient: Transcoder!
  faceValue: BigDecimal!
  faceValueUSD: BigDecimal!
  winProb: BigInt!
  senderNonce: BigInt!
  recipientRand: BigInt!
  auxData: Bytes!
}

type DepositFundedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  sender: Broadcaster!
  amount: BigDecimal!
}

type ReserveFundedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  reserveHolder: Broadcaster!
  amount: BigDecimal!
}

type ReserveClaimedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  reserveHolder: Broadcaster!
  claimant: Transcoder!
  amount: BigDecimal!
}

type WithdrawalEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  sender: Broadcaster!
  deposit: BigDecimal!
  reserve: BigDecimal!
}

type SetCurrentRewardTokensEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  currentMintableTokens: BigDecimal!
  currentInflation: BigInt!
}

type PauseEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
}

type UnpauseEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
}

type ParameterUpdateEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  param: String!
}

type VoteEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  voter: String!
  choiceID: BigInt!
  poll: Poll!
}

type PollCreatedEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  poll: Poll!
  proposal: Bytes!
  endBlock: BigInt!
  quorum: BigInt!
  quota: BigInt!
}

type ServiceURIUpdateEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  addr: String!
  serviceURI: String!
}

type MintEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  to: String!
  amount: BigDecimal!
}

type BurnEvent implements Event @entity {
  id: ID!
  transaction: Transaction!
  timestamp: Int!
  round: Round!
  value: BigDecimal!
}
