"""
Livepeer protocol global parameters
"""
type Protocol @entity {
  "ID is set to 0"
  id: ID!
  "Per round inflation rate"
  inflation: BigInt!
  "Change in inflation rate per round until the target bonding rate is achieved"
  inflationChange: BigInt!
  "Max number of rounds that a caller can claim earnings for at once"
  maxEarningsClaimsRounds: Int!
    @deprecated(reason: "This constraint of was removed as of LIP-52")
  "Total active transcoders"
  numActiveTranscoders: Int!
  "True if the protocol is paused"
  paused: Boolean!
  "Target bonding rate (participation) that determines whether inflation should increase or decrease"
  targetBondingRate: BigInt!
  "Time in blocks needed to wait to unstake"
  unbondingPeriod: BigInt!
  "Time in blocks delegators have to review transcoder information without changes"
  lockPeriod: BigInt!
  "Lock period of a round as a % of round length"
  roundLockAmount: BigInt!
  "The total amount of active LPT staked"
  totalActiveStake: BigDecimal!
  "Total broadcaster fees transcoders have accumulated in ETH"
  totalVolumeETH: BigDecimal!
  "Total broadcaster fees transcoders have accumulated in USD"
  totalVolumeUSD: BigDecimal!
  "Ratio of total active stake to total supply"
  participationRate: BigDecimal!
  "Current round the protocol is in"
  currentRound: Round
  "Round that was last initialized"
  lastInitializedRound: Round
  "Round when round length was last updated"
  lastRoundLengthUpdateRound: Round
  "Round length in blocks"
  roundLength: BigInt!
  "Block when round length was last updated"
  lastRoundLengthUpdateStartBlock: BigInt!
  "Livepeer Token supply"
  totalSupply: BigDecimal!
  "Total winning tickets"
  winningTicketCount: Int!
  "Total rounds"
  roundCount: Int!
}

"""
Perform transcoding work for the network. The transcoders with the most delegated stake are elected as active transcoders that process transcode jobs for the network.
"""
type Transcoder @entity {
  "Transcoder's ETH address"
  id: ID!
  "Round in which the transcoder became active - 0 if inactive"
  activationRound: BigInt!
  "Round in which the transcoder will become inactive"
  deactivationRound: BigInt!
  "Round for which the stake was last updated while the transcoder is active"
  lastActiveStakeUpdateRound: BigInt!
  "Whether or not the transcoder is active"
  active: Boolean!
  "Status of the transcoder"
  status: TranscoderStatus!
  "Last round that the transcoder called reward"
  lastRewardRound: Round
  "% of block reward cut paid to transcoder by a delegator"
  rewardCut: BigInt!
  "% of fees paid to delegators by transcoder"
  feeShare: BigInt!
  "Price per segment for a stream"
  pricePerSegment: BigInt
    @deprecated(reason: "Price negotiation moved offchain")
  "Pending price per segment for next round if the transcoder is active"
  pendingPricePerSegment: BigInt
    @deprecated(reason: "Price negotiation moved offchain")
  "Pending block reward cut for next round if the transcoder is active"
  pendingRewardCut: BigInt @deprecated(reason: "Field no longer used")
  "Pending fee share for next round if the transcoder is active"
  pendingFeeShare: BigInt @deprecated(reason: "Field no longer used")
  "Total tokens delegated toward a transcoder (including their own)"
  totalStake: BigDecimal!
  "Total fees generated by the transcoder in ETH (before distribution to delegators)"
  totalVolumeETH: BigDecimal!
  "Total fees generated by the transcoder in USD (before distribution to delegators)"
  totalVolumeUSD: BigDecimal!
  "Pools associated with the transcoder"
  pools: [Pool!] @derivedFrom(field: "delegate")
  "Delegators bonded to the transcoder"
  delegators: [Delegator!] @derivedFrom(field: "delegate")
  "Delegator that registered this transcoder"
  delegator: Delegator
  "Service URI endpoint that can be used to send off-chain requests"
  serviceURI: String
}

enum TranscoderStatus @entity {
  NotRegistered
  Registered
}

"""
Represents a transcoder's rewards and fees to be distributed to delegators
"""
type Pool @entity {
  "Unique identifer for the pool (formed using the transcoder's address and round number)"
  id: ID!
  "Round associated with the pool"
  round: Round!
  "Transcoder associated with the pool"
  delegate: Transcoder!
  "Fees collected in the pool"
  fees: BigDecimal
  "Total reward tokens collected in the pool"
  rewardTokens: BigDecimal
  "Transcoder's total stake during the earnings pool's round"
  totalStake: BigDecimal!
  "Transcoder's reward cut during the earnings pool's round"
  rewardCut: BigInt!
  "Transcoder's fee share during the earnings pool's round"
  feeShare: BigInt!
}

"""
The Livepeer protocol is round based and each round is represented by some number of Ethereum blocks.
"""
type Round @entity {
  "Round number"
  id: ID!
  "Whether the round was initialized"
  initialized: Boolean!
  "Number of blocks this round lasts for"
  length: BigInt!
  "Start block for the round"
  startBlock: BigInt!
  "End block for the round"
  endBlock: BigInt!
  "Pools associated with the round"
  pools: [Pool!] @derivedFrom(field: "round")
  "Mintable tokens for the round"
  mintableTokens: BigDecimal!
  "Fees generated this round in ETH"
  volumeETH: BigDecimal!
  "Fees generated this round in USD"
  volumeUSD: BigDecimal!
  "Total active stake during the round"
  totalActiveStake: BigDecimal!
  "Total Livepeer token supply during the round"
  totalSupply: BigDecimal!
  "Participation rate during the round (totalActiveStake/totalSupply)"
  participationRate: BigDecimal!
  "Total stake moved from one delegate to another during the round"
  movedStake: BigDecimal!
  "Total amount of new stake introduced during the round"
  newStake: BigDecimal!
}

"""
Bonded accounts who have delegated their stake towards a transcoder candidate
"""
type Delegator @entity {
  "ETH address of a delegator"
  id: ID!
  "ETH address of the delegate (the one whom the delegator has bonded to)"
  delegate: Transcoder
  "Round the delegator becomes bonded and delegated to its delegate"
  startRound: BigInt!
  "Last round that the delegator claimed reward and fee pool shares"
  lastClaimRound: Round
  "Amount of Livepeer Token a delegator currently has bonded"
  bondedAmount: BigDecimal!
  "Amount of Livepeer Token a delegator has bonded over its lifetime separate from rewards"
  principal: BigDecimal!
  "Amount of Livepeer Token a delegator has unbonded over its lifetime"
  unbonded: BigDecimal!
  "Amount of fees a delegator has collected"
  fees: BigDecimal!
  "Amount of fees withdrawn"
  withdrawnFees: BigDecimal!
  "Amount of Livepeer Token the delegator has delegated"
  delegatedAmount: BigDecimal!
  "Unbonding locks associated with the delegator"
  unbondingLocks: [UnbondingLock!] @derivedFrom(field: "delegator")
}

"""
Broadcasters pay transcoders to do the work of transcoding in exchange for fees
"""
type Broadcaster @entity {
  "ETH address of a broadcaster"
  id: ID!
  "Amount of funds deposited"
  deposit: BigDecimal!
  "Amount of funds in reserve"
  reserve: BigDecimal!
}

"""
Get an unbonding lock for a delegator
"""
type UnbondingLock @entity {
  "Unique unlock identifer"
  id: ID!
  "unbonding lock id"
  unbondingLockId: Int!
  "Delegator address this lock belongs to"
  delegator: Delegator!
  "Address of delegate unbonding from"
  delegate: Transcoder!
  "Amount being unbonded"
  amount: BigDecimal!
  "Round number when the unbonding amount will be available for withdrawal"
  withdrawRound: BigInt!
}

"""
Stake weighted poll
"""
type Poll @entity {
  "Poll address"
  id: ID!
  "IPFS multihash for the proposal"
  proposal: String!
  "Block at which the poll ends and votes can no longer be submitted"
  endBlock: BigInt!
  "Minimum amount of participation (total stake including inactive stake) required for a poll to pass"
  quorum: BigInt!
  "Minimum amount of yes votes required for a poll to pass"
  quota: BigInt!
  "Poll tally"
  tally: PollTally
  "Votes belonging to a poll"
  votes: [Vote!]
}

"""
Stake weighted tally associated with a poll
"""
type PollTally @entity {
  "Poll address"
  id: ID!
  "Stake voted yes"
  yes: BigDecimal
  "Stake voted no"
  no: BigDecimal
}

"""
Vote data
"""
type Vote @entity {
  "Voter address + poll address"
  id: ID!
  "Vote caster"
  voter: String!
  "Stake weighted vote"
  voteStake: BigDecimal
  "This will be non-zero if voter is an transcoder and any of the its delegators voted"
  nonVoteStake: BigDecimal
  "Vote choice"
  choiceID: PollChoice
  "Poll associated with this vote"
  poll: Poll
  "True if the voter was a registered transcoder during the poll period"
  registeredTranscoder: Boolean
}

enum PollChoice @entity {
  Yes
  No
}

"""
Protocol data accumulated and condensed into day stats
"""
type Day @entity {
  "Timestamp rounded to current day by dividing by 86400"
  id: ID!
  "The date beginning at 12:00am UTC"
  date: Int!
  "Fees generated this day in ETH"
  volumeETH: BigDecimal!
  "Fees generated this day in USD"
  volumeUSD: BigDecimal!
  "Total active stake during the day"
  totalActiveStake: BigDecimal!
  "Total Livepeer token supply during the day"
  totalSupply: BigDecimal!
  "Participation rate during the day (totalActiveStake/totalSupply)"
  participationRate: BigDecimal!
}

"""
Transcoder data accumulated and condensed into day stats
"""
type TranscoderDay @entity {
  "Combination of the transcoder address and the timestamp rounded to current day by dividing by 86400"
  id: ID!
  "The date beginning at 12:00am UTC"
  date: Int!
  "Fees generated this day in ETH"
  volumeETH: BigDecimal!
  "Fees generated this day in USD"
  volumeUSD: BigDecimal!
  "Transcoder associated with the day"
  transcoder: Transcoder!
}

###############################################################################
#
# Event types && transactions for historical records
#
###############################################################################
interface Event {
  id: ID!
  timestamp: Int!
  transaction: Transaction!
  round: Round!
}

"""
Transaction entities are created for each Ethereum transaction that contains an interaction within Livepeer contracts.
"""
type Transaction @entity {
  "Ethereum transaction hash"
  id: ID!
  "Block transaction was mined in"
  blockNumber: BigInt!
  "Timestamp for transaction"
  timestamp: Int!
  "Amount of gas used in the transaction"
  gasUsed: BigInt!
  "Cost per unit of gas specified for the transaction"
  gasPrice: BigInt!
  "The sending party of the transaction"
  from: String!
  "The receiving party of the transaction"
  to: String!
  "The events emitted within this transaction"
  events: [Event!] @derivedFrom(field: "transaction")
}

"""
BondEvent entities are created for every emitted Bond event.
"""
type BondEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in, used to sort"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Delegator's current total bonded amount"
  bondedAmount: BigDecimal!
  "Additional amount added to bonded amount"
  additionalAmount: BigDecimal!
  "Reference to the Delegator's new delegate"
  newDelegate: Transcoder!
  "Reference to the Delegator's old delegate"
  oldDelegate: Transcoder!
  "Reference to the Delegator that bonded"
  delegator: Delegator!
}

"""
UnbondEvent entities are created for every emitted Unbond event.
"""
type UnbondEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Amount unbonded in the transaction"
  amount: BigDecimal!
  "The future round in which the Delegator may withdraw its unbonded stake"
  withdrawRound: BigInt!
  "The unbonding lock ID associated with this transaction, used to optionally rebond the amount"
  unbondingLockId: Int
  "Reference to the delegate unbonded from"
  delegate: Transcoder!
  "Reference to the Delegator that unbonded"
  delegator: Delegator!
}

"""
RebondEvent entities are created for every emitted Rebond event.
"""
type RebondEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegator that rebonded"
  delegator: Delegator!
  delegate: Transcoder!
  amount: BigDecimal!
  unbondingLockId: Int!
}

"""
RewardEvent entities are created for every emitted Reward event.
"""
type RewardEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Amount of inflationary token rewards claimed"
  rewardTokens: BigDecimal!
  "Reference to the delegate that claimed its inflationary token reward"
  delegate: Transcoder!
}

"""
TranscoderActivatedEvent entities are created for every emitted TranscoderActivated event.
"""
type TranscoderActivatedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegate that will be active"
  delegate: Transcoder!
  "Future round in which the delegate will become active"
  activationRound: BigInt!
}

"""
TranscoderDeactivatedEvent entities are created for every emitted TranscoderDeactivated event.
"""
type TranscoderDeactivatedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegate that will become deactive"
  delegate: Transcoder!
  "Future round in which the delegate will become deactive"
  deactivationRound: BigInt!
}

"""
EarningsClaimedEvent entities are created for every emitted EarningsClaimed event.
"""
type EarningsClaimedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegator that claimed its earnings"
  delegator: Delegator!
  "Reference to the delegator's delegate"
  delegate: Transcoder!
  "First round that the delegator's pending stake was computed from"
  startRound: BigInt!
  "Last round that the delegator's pending stake was computed from"
  endRound: Round!
  "Reward tokens claimed by the delegator"
  rewardTokens: BigDecimal!
  "Fees claimed by the delegator"
  fees: BigDecimal!
}

"""
TranscoderUpdateEvent entities are created for every emitted TranscoderUpdate event.
"""
type TranscoderUpdateEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegate that was updated"
  delegate: Transcoder!
  "Delegate's updated reward cut"
  rewardCut: BigInt!
  "Delegate's updated fee share"
  feeShare: BigInt!
}

"""
TranscoderSlashedEvent entities are created for every emitted TranscoderSlashed event.
"""
type TranscoderSlashedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegate that was slashed"
  delegate: Transcoder!
  "Finder that proved a transcoder violated a slashing condition. Null address if there is no finder"
  finder: Bytes!
  "Percentage of transcoder bond to be slashed"
  penalty: BigDecimal!
  "Percentage of penalty awarded to finder. Zero if there is no finder"
  finderReward: BigInt!
}

"""
TranscoderResignedEvent entities are created for every emitted TranscoderResigned event.
"""
type TranscoderResignedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegate that resigned"
  delegate: Transcoder!
}

"""
TranscoderEvictedEvent entities are created for every emitted TranscoderEvicted event.
"""
type TranscoderEvictedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegate that was evicted"
  delegate: Transcoder!
}

"""
WithdrawStakeEvent entities are created for every emitted WithdrawStake event.
"""
type WithdrawStakeEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegator that withdraw its stake"
  delegator: Delegator!
  "Unbonding lock ID that was deleted upon withdrawal"
  unbondingLockId: Int
  "Amount of stake withdrawn"
  amount: BigDecimal!
}

"""
WithdrawFeesEvent entities are created for every emitted WithdrawFees event.
"""
type WithdrawFeesEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the delegator that withdraw its fees"
  delegator: Delegator!
  "Amount of fees withdrawn"
  amount: BigDecimal!
}

"""
NewRoundEvent entities are created for every emitted NewRound event.
"""
type NewRoundEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Block hash for the round"
  blockHash: String!
}

"""
WinningTicketRedeemedEvent entities are created for every emitted WinningTicketRedeemed event.
"""
type WinningTicketRedeemedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the broadcaster who sent the fees"
  sender: Broadcaster!
  "Reference to the recipient of the broadcaster fees"
  recipient: Transcoder!
  "Face value of ticket paid to recipient"
  faceValue: BigDecimal!
  "Amount of fees the winning ticket was redeemed for in in USD"
  faceValueUSD: BigDecimal!
  "The winning probability of the ticket"
  winProb: BigInt!
  "Sender's monotonically increasing counter for each ticket"
  senderNonce: BigInt!
  "keccak256 hash commitment to recipient's random value"
  recipientRand: BigInt!
  "Auxilary data included in ticket used for additional validation"
  auxData: Bytes!
}

"""
DepositFundedEvent entities are created for every emitted DepositFunded event.
"""
type DepositFundedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the broadcaster that deposited the broadcasting fees"
  sender: Broadcaster!
  "Amount of broadcasting fees deposited"
  amount: BigDecimal!
}

"""
ReserveFundedEvent entities are created for every emitted ReserveFunded event.
"""
type ReserveFundedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to reserve holder"
  reserveHolder: Broadcaster!
  "Amount of funds added to reserve"
  amount: BigDecimal!
}

"""
ReserveClaimedEvent entities are created for every emitted ReserveClaimed event.
"""
type ReserveClaimedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the reserve holder"
  reserveHolder: Broadcaster!
  "Reference to the claimant"
  claimant: Transcoder!
  "Amount of funds claimed by claimant from the reserve for the reserve holder"
  amount: BigDecimal!
}

"""
WithdrawalEvent entities are created for every emitted Withdrawal event.
"""
type WithdrawalEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the broadcaster withdrawing its deposit and reserve"
  sender: Broadcaster!
  "Deposit amount withdrawn"
  deposit: BigDecimal!
  "Reserve amount withdrawn"
  reserve: BigDecimal!
}

"""
SetCurrentRewardTokensEvent entities are created for every emitted SetCurrentRewardTokens event.
"""
type SetCurrentRewardTokensEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Number of mintable tokens for the round"
  currentMintableTokens: BigDecimal!
  "Current inflation during the round"
  currentInflation: BigInt!
}

"""
PauseEvent entities are created for every emitted Pause event.
"""
type PauseEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
}

"""
UnpauseEvent entities are created for every emitted Unpause event.
"""
type UnpauseEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
}

"""
ParameterUpdateEvent entities are created for every emitted ParameterUpdate event.
"""
type ParameterUpdateEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Parameter that was updated"
  param: String!
}

"""
VoteEvent entities are created for every emitted Vote event.
"""
type VoteEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Address belonging to the voter"
  voter: String!
  "Voter choice. Zero means yes and one means no"
  choiceID: BigInt!
  "Reference to the poll this vote was casted in"
  poll: Poll!
}

"""
PollCreatedEvent entities are created for every emitted PollCreated event.
"""
type PollCreatedEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Reference to the poll that was created"
  poll: Poll!
  "IPFS content hash representing proposal"
  proposal: Bytes!
  "Ethereum block in which this poll ends"
  endBlock: BigInt!
  "The minimum amount of stake-weighted votes for this poll's outcome to be considered valid"
  quorum: BigInt!
  "The minimum amount of stake-weighted 'yes' votes needed for the poll to pass"
  quota: BigInt!
}

"""
ServiceURIUpdateEvent entities are created for every emitted ServiceURIUpdate event.
"""
type ServiceURIUpdateEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Address of sender"
  addr: String!
  "Service URI endpoint for the caller"
  serviceURI: String!
}

"""
MintEvent entities are created for every emitted Mint event.
"""
type MintEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Token smart contract address"
  to: String!
  "Amount of tokens minted"
  amount: BigDecimal!
}

"""
BurnEvent entities are created for every emitted Burn event.
"""
type BurnEvent implements Event @entity {
  "Ethereum transaction hash + event log index"
  id: ID!
  "Reference to the transaction the event was included in"
  transaction: Transaction!
  "Timestamp of the transaction the event was included in"
  timestamp: Int!
  "Reference to the round the event occured in"
  round: Round!
  "Amount of tokens burned"
  value: BigDecimal!
}
